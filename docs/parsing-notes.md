# Обработка специальных символов в правилах грамматики

## Проблема

При работе с классом `TableBuilder` и разборе правил грамматики мы столкнулись с проблемами, связанными со специальными символами, которые выполняют двойную функцию:

1. Символ `-` (минус) используется как оператор в выражениях и как разделитель в определениях правил.
2. Символ `/` (слеш) используется как оператор деления и как разделитель между правилами правой части и направляющими множествами.

Это создает конфликты при разборе правил грамматики в модуле `ParseRules`.

## Подходы к решению

### 1. Имена токенов вместо символов

Используйте имена токенов вместо фактических символов в правилах грамматики, затем замените их фактическими символами после построения направляющих множеств, но перед созданием таблицы:

```typescript
// Исходная грамматика с именами токенов
const rawRules = `
<S> -> <E> #
<E> -> <T> <E'>
<E'> -> OP_PLUS <T> <E'> | OP_MINUS <T> <E'> | e
<T> -> <F> <T'>
<T'> -> OP_MUL <F> <T'> | OP_DIV <F> <T'> | e
<F> -> id | int | float | LPAREN <E> RPAREN
`;

// Построение направляющих множеств
const guidesBuilder = new GuidesBuilder(rawRules);
const guidedRules = guidesBuilder.buildGuidedRules();

// Замена имен токенов фактическими символами
const fixedRules = guidedRules
  .replace(/OP_PLUS/g, '+')
  .replace(/OP_MINUS/g, '-')
  .replace(/OP_MUL/g, '*')
  .replace(/OP_DIV/g, '/')
  .replace(/LPAREN/g, '(')
  .replace(/RPAREN/g, ')');
```

### 2. Улучшенный разбор правил

Измените функцию `parseRules` в `TableBuilder/parseRules/ParseRules.ts`, чтобы обрабатывать особые случаи для операторов:

```typescript
// Обрабатываем строку по-разному, если она содержит правило со знаком минус
const ruleIndex = line.indexOf(' - ');
if (ruleIndex !== -1) {
  nonTerm = line.substring(0, ruleIndex).trim();
  altStr = line.substring(ruleIndex + 3).trim();
} else {
  const parts = line.split('-');
  if (parts.length !== 2) {
    throw new Error(`Invalid rule format: ${line}`);
  }
  nonTerm = parts[0].trim();
  altStr = parts[1].trim();
}
```

Аналогично для оператора слеша, мы можем изменить `getRuleRightSide`:

```typescript
if (str.trim().startsWith('- ') || str.trim() === '-') {
  // Это правило, которое начинается со знака минус
  const slashIndex = str.indexOf('/');
  if (slashIndex === -1) {
    throw new Error(`Invalid rule format (missing guide separator): ${str}`);
  }
  
  rightSideStr = str.substring(0, slashIndex).trim();
  guidesStr = str.substring(slashIndex + 1).trim();
}
```

### 3. Упрощение грамматики

Для случаев, когда специальные символы вызывают проблемы, вы можете упростить грамматику, чтобы избежать проблемных операторов:

```typescript
// Упрощенная грамматика без проблемных операторов
const rawRules = `
<S> -> <E> #
<E> -> <T> <E'>
<E'> -> + <T> <E'> | e
<T> -> <F> <T'>
<T'> -> * <F> <T'> | e
<F> -> id | int | ( <E> )
`;
```

## Рекомендации

1. **Используйте имена токенов**: При определении правил грамматики предпочитайте использовать имена токенов, такие как `OP_PLUS` вместо `+`.

2. **Замена перед построением таблицы**: Если вы используете имена токенов, замените их фактическими символами после построения направляющих множеств, но перед созданием таблицы.

3. **Модификация парсеров**: Убедитесь, что ваша логика разбора может обрабатывать особые случаи для операторов, которые совпадают с синтаксисом.

4. **Экранирование символов**: Рассмотрите возможность введения механизмов экранирования для специальных символов в обозначениях вашей грамматики.

5. **Лучшие разделители**: Вместо перегрузки `-` и `/`, рассмотрите возможность использования других символов, таких как `=>` для правил и `||` для направляющих множеств.

Следуя этим рекомендациям, вы можете избежать конфликтов между операторами и синтаксическими символами в определениях вашей грамматики. 