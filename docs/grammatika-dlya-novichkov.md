# Грамматики, альтернативы и их использование в компиляторах

## Содержание

1. [Введение](#введение)
2. [Основные понятия](#основные-понятия)
   - [Грамматика](#грамматика)
   - [Правила грамматики](#правила-грамматики)
   - [Терминалы и нетерминалы](#терминалы-и-нетерминалы)
   - [Альтернативы](#альтернативы)
3. [Типы грамматик по Хомскому](#типы-грамматик-по-хомскому)
4. [Контекстно-свободные грамматики](#контекстно-свободные-грамматики)
5. [LL-грамматики и LL-парсинг](#ll-грамматики-и-ll-парсинг)
   - [Что такое LL-парсер](#что-такое-ll-парсер)
   - [Направляющие множества](#направляющие-множества)
   - [Таблица LL-парсера](#таблица-ll-парсера)
6. [Устранение левой рекурсии](#устранение-левой-рекурсии)
7. [Практическое использование](#практическое-использование)
   - [Определение грамматики](#определение-грамматики)
   - [Создание парсера](#создание-парсера)
   - [Обработка ошибок](#обработка-ошибок)
8. [Примеры грамматик](#примеры-грамматик)
   - [Арифметические выражения](#арифметические-выражения)
   - [Простые операторы языка программирования](#простые-операторы-языка-программирования)
9. [Рекомендации по решению проблем](#рекомендации-по-решению-проблем)
10. [Заключение](#заключение)

## Введение

Грамматики являются формальным способом описания структуры языка программирования, математических выражений или других формальных языков. Они определяют правила, по которым строятся корректные конструкции языка. В компиляторах и интерпретаторах грамматики используются для анализа исходного кода и преобразования его в структурированное представление, которое можно в дальнейшем обрабатывать.

Эта инструкция предназначена для начинающих разработчиков компиляторов и тех, кто хочет понять, как работает синтаксический анализ (парсинг) в языках программирования.

## Основные понятия

### Грамматика

**Грамматика** — это формальная система, которая определяет, какие последовательности символов являются синтаксически правильными в конкретном языке. Она состоит из набора правил, которые указывают, как формируются допустимые последовательности.

Формально грамматика G определяется четверкой (N, T, P, S), где:
- N — конечное множество нетерминальных символов
- T — конечное множество терминальных символов
- P — конечное множество правил вывода
- S — начальный символ (аксиома), S ∈ N

### Правила грамматики

**Правило грамматики** — это предписание, которое указывает, как один символ (обычно нетерминальный) может быть заменен последовательностью других символов (терминальных и нетерминальных).

Правило имеет вид: A → α, где:
- A — нетерминальный символ
- α — последовательность терминальных и нетерминальных символов (может быть пустой)

Например, правило `<выражение> → <терм> + <выражение>` означает, что выражение можно заменить на терм, за которым следует символ "+" и другое выражение.

### Терминалы и нетерминалы

**Терминальные символы** (терминалы) — это базовые элементы языка, которые не могут быть далее разбиты на составляющие. Это символы, которые появляются в конечных строках языка. Примеры: числа, идентификаторы, знаки операций (+, -, *, /), ключевые слова.

**Нетерминальные символы** (нетерминалы) — это абстрактные категории, используемые в грамматике для группировки и структурирования правил. Они не появляются в конечной строке языка, а заменяются согласно правилам. Обычно обозначаются в угловых скобках, например: `<выражение>`, `<оператор>`, `<условие>`.

### Альтернативы

**Альтернативы** — это различные способы, которыми нетерминальный символ может быть заменён. Они разделяются символом `|` (вертикальная черта).

Например:
```
<терм> → <фактор> | <терм> * <фактор> | <терм> / <фактор>
```

Это правило указывает, что терм может быть:
1. Просто фактором
2. Термом, умноженным на фактор
3. Термом, деленным на фактор

## Типы грамматик по Хомскому

Ноам Хомский предложил иерархию грамматик, которая классифицирует их по возрастающей выразительной мощности:

1. **Регулярные грамматики (тип 3)** — самые простые, описывают регулярные языки. Используются для лексического анализа.
   
2. **Контекстно-свободные грамматики (тип 2)** — описывают контекстно-свободные языки. Широко используются в синтаксическом анализе языков программирования.
   
3. **Контекстно-зависимые грамматики (тип 1)** — более мощные, но сложные для анализа. Редко используются в компиляторах.
   
4. **Грамматики без ограничений (тип 0)** — самые мощные, эквивалентны машине Тьюринга.

В разработке компиляторов наиболее часто используются контекстно-свободные грамматики.

## Контекстно-свободные грамматики

**Контекстно-свободная грамматика (КС-грамматика)** — это грамматика, в которой левая часть каждого правила состоит ровно из одного нетерминального символа. Это означает, что замена нетерминала происходит независимо от контекста, в котором он находится.

Формальное определение: все правила имеют вид A → α, где A — один нетерминальный символ, α — строка терминальных и нетерминальных символов.

Пример КС-грамматики для простых арифметических выражений:
```
<expr> → <expr> + <term> | <expr> - <term> | <term>
<term> → <term> * <factor> | <term> / <factor> | <factor>
<factor> → ( <expr> ) | id | number
```

КС-грамматики используются для описания синтаксиса языков программирования, поскольку они достаточно мощные, чтобы выразить большинство конструкций, и при этом допускают эффективные алгоритмы анализа.

## LL-грамматики и LL-парсинг

### Что такое LL-парсер

**LL-парсер** — это нисходящий синтаксический анализатор, который обрабатывает входную строку слева направо (первая L), используя левосторонний вывод (вторая L). LL-парсеры работают с подмножеством контекстно-свободных грамматик, называемых LL-грамматиками.

LL(k)-парсер использует k символов предпросмотра для принятия решения о том, какое правило применить. В нашем проекте реализован LL(1)-парсер, который использует только один символ предпросмотра.

### Направляющие множества

**Направляющие множества** — это ключевой элемент LL-парсинга. Они помогают парсеру выбрать, какое правило применить, глядя на текущий входной символ.

Для каждого правила A → α в LL(1)-грамматике мы определяем множество FIRST(α), которое содержит все терминальные символы, которые могут начинать строки, выводимые из α.

Если α может выводить пустую строку (обозначаемую как ε), тогда мы также используем множество FOLLOW(A), которое содержит все терминальные символы, которые могут следовать за A в любом валидном выводе.

Направляющее множество для правила A → α, обозначаемое как GUIDE(A → α), определяется как:
- FIRST(α), если ε ∉ FIRST(α)
- (FIRST(α) - {ε}) ∪ FOLLOW(A), если ε ∈ FIRST(α)

В нашей реализации класс `GuidesBuilder` отвечает за построение направляющих множеств.

### Таблица LL-парсера

**Таблица LL-парсера** — это двумерная таблица, которая для каждой пары (нетерминал, терминал) указывает, какое правило следует применить.

Таблица строится на основе направляющих множеств следующим образом:
1. Для каждого правила A → α в грамматике
2. Для каждого терминала t в GUIDE(A → α)
3. Добавить запись [A, t] = α в таблицу

Если в одну и ту же ячейку таблицы попадает более одного правила, то грамматика не является LL(1)-грамматикой, и парсер не сможет однозначно определить, какое правило применить.

В нашей реализации класс `TableBuilder` отвечает за построение таблицы парсера.

## Устранение левой рекурсии

**Левая рекурсия** — это ситуация, когда нетерминал непосредственно или косвенно выводит сам себя в начале правила. Например:
```
<expr> → <expr> + <term> | <term>
```

Это проблема для LL-парсеров, поскольку они работают сверху вниз, и левая рекурсия приведет к бесконечному циклу.

Левую рекурсию можно устранить путем преобразования грамматики. Для непосредственной левой рекурсии:
```
A → A α | β
```
можно переписать как:
```
A → β A'
A' → α A' | ε
```

Пример преобразования для выражений:
```
<expr> → <expr> + <term> | <term>
```
преобразуется в:
```
<expr> → <term> <expr'>
<expr'> → + <term> <expr'> | ε
```

## Практическое использование

### Определение грамматики

В нашем проекте грамматика определяется в текстовом файле с использованием специального синтаксиса. Например:

```
<S> -> <E> #
<E> -> <T> <E'>
<E'> -> + <T> <E'> | e
<T> -> <F> <T'>
<T'> -> * <F> <T'> | e
<F> -> id | int | ( <E> )
```

Здесь:
- `<S>`, `<E>`, `<T>` и т.д. — нетерминалы
- `+`, `*`, `(`, `)`, `id`, `int` — терминалы
- `#` — специальный символ конца ввода
- `e` — обозначение пустой строки (эпсилон)
- `->` — разделитель между левой и правой частью правила
- `|` — разделитель между альтернативами

### Создание парсера

Процесс создания парсера в нашем проекте состоит из следующих шагов:

1. **Чтение правил грамматики**:
   ```typescript
   const rawRules = fs.readFileSync('grammar.txt', 'utf8');
   ```

2. **Построение направляющих множеств**:
   ```typescript
   const guidesBuilder = new GuidesBuilder(rawRules);
   const guidedRules = guidesBuilder.buildGuidedRules();
   ```

3. **Построение таблицы парсера**:
   ```typescript
   const tableBuilder = new TableBuilder(guidedRules);
   const table = tableBuilder.buildTable();
   ```

4. **Создание LL-парсера**:
   ```typescript
   const parser = new LLParser(table);
   ```

5. **Использование парсера для анализа выражений**:
   ```typescript
   const result = parser.parse('a + b * c');
   if (result) {
     console.log('Выражение корректно');
   } else {
     const error = parser.getError();
     console.log(`Ошибка: ${stringifyError(error)}`);
   }
   ```

### Обработка ошибок

LL-парсер может обнаруживать различные типы ошибок в процессе анализа:

1. **Неожиданный символ** — входной символ не соответствует ожидаемому терминалу
2. **Несоответствие правилу** — нет правила для текущей комбинации нетерминала и входного символа
3. **Неполный ввод** — входная строка закончилась до завершения разбора
4. **Избыточный ввод** — разбор завершен, но во входной строке остались символы

В нашем проекте ошибки обрабатываются с помощью функции `stringifyError`, которая преобразует код ошибки в понятное сообщение.

## Примеры грамматик

### Арифметические выражения

Простая грамматика для арифметических выражений с учетом приоритета операций:

```
<выражение> -> <терм> <выражение'>
<выражение'> -> + <терм> <выражение'> | - <терм> <выражение'> | e
<терм> -> <фактор> <терм'>
<терм'> -> * <фактор> <терм'> | / <фактор> <терм'> | e
<фактор> -> id | число | ( <выражение> )
```

Эта грамматика позволяет разобрать выражения типа:
- `a + b * c`
- `(a + b) * c`
- `a * b + c / d`
- `(a + b) * (c - d)`

### Простые операторы языка программирования

Грамматика для простых операторов языка программирования:

```
<программа> -> <оператор> <программа> | e
<оператор> -> <присваивание> | <если> | <пока>
<присваивание> -> id = <выражение> ;
<если> -> if ( <условие> ) { <программа> } <иначе>
<иначе> -> else { <программа> } | e
<пока> -> while ( <условие> ) { <программа> }
<условие> -> <выражение> <оп_сравнения> <выражение>
<оп_сравнения> -> == | != | < | > | <= | >=
```

Эта грамматика позволяет разобрать конструкции типа:
```
x = 10;
if (x > 5) {
  y = x * 2;
} else {
  y = x / 2;
}
while (y > 0) {
  y = y - 1;
}
```

## Рекомендации по решению проблем

### Проблемы с специальными символами

При работе с грамматиками часто возникают проблемы с специальными символами, которые используются как в синтаксисе языка, так и в обозначениях грамматики (например, `-`, `/`).

Рекомендации:
1. Используйте имена токенов вместо символов: `OP_PLUS` вместо `+`
2. Заменяйте имена токенов на символы после построения направляющих множеств
3. Используйте другие символы в грамматике: `=>` вместо `->`, `||` вместо `|`

### Устранение неоднозначности

Если ваша грамматика не является LL(1), что проявляется в конфликтах в таблице парсера, можно:
1. Факторизовать грамматику (извлечь общие префиксы)
2. Устранить левую рекурсию
3. Использовать более мощные методы анализа (например, LR-парсеры)

### Отладка грамматики

Для отладки грамматики полезно:
1. Визуализировать направляющие множества
2. Проверять наличие конфликтов в таблице парсера
3. Тестировать на простых примерах
4. Постепенно усложнять грамматику, добавляя новые конструкции
5. Использовать трассировку процесса разбора для понимания, где происходят ошибки

## Заключение

Грамматики — это мощный инструмент для описания синтаксиса языков программирования и других формальных языков. Понимание принципов работы грамматик и парсеров важно для любого разработчика компиляторов или интерпретаторов.

В этой инструкции мы рассмотрели основные понятия теории формальных грамматик, особенности LL-грамматик и LL-парсинга, а также практические аспекты использования грамматик в реальных проектах.

Используя предоставленную информацию и примеры, вы сможете создавать свои грамматики для различных языков и использовать их с реализованным в проекте LL-парсером. 